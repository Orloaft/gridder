# Combat Simulation & AI Architecture for React/TypeScript Autobattler

## Executive Summary
React/TypeScript can absolutely handle complex autobattler combat simulation. The key is separating **game state/logic** (pure TypeScript) from **rendering** (React). This document outlines architecture patterns, performance optimizations, and AI decision-making systems suitable for your grid-based autobattler.

---

## Core Architecture Pattern

### The Golden Rule: Separate Logic from Rendering

```typescript
// ❌ BAD: Combat logic mixed with React
function CombatGrid() {
  const [heroes, setHeroes] = useState([]);
  
  useEffect(() => {
    // DON'T DO THIS - logic in React hooks
    const interval = setInterval(() => {
      heroes.forEach(hero => {
        if (hero.canAttack()) {
          hero.attack(); // Mutation in render cycle
        }
      });
    }, 100);
  }, [heroes]);
}

// ✅ GOOD: Pure game logic class
class CombatSimulation {
  private heroes: Hero[] = [];
  private enemies: Enemy[] = [];
  private gameTime: number = 0;
  
  public tick(deltaTime: number): void {
    this.gameTime += deltaTime;
    this.updateUnits(deltaTime);
    this.checkCollisions();
    this.processAbilities();
    // Pure logic, no React
  }
}

// React just renders the state
function CombatGrid() {
  const simulation = useRef(new CombatSimulation());
  const [gameState, setGameState] = useState(simulation.current.getState());
  
  useEffect(() => {
    const interval = setInterval(() => {
      simulation.current.tick(100); // Update logic
      setGameState(simulation.current.getState()); // Sync to React
    }, 100);
    return () => clearInterval(interval);
  }, []);
}
```

---

## Recommended Architecture: ECS-Lite Pattern

### Entity-Component-System (Simplified for TypeScript)

**Why ECS for autobattlers:**
- Clean separation of data (components) and behavior (systems)
- Easy to add new enemy types without touching core logic
- Performance-friendly (iterate arrays, not class hierarchies)
- Scales well to 50+ units on screen

```typescript
// ========================================
// ENTITIES: Just IDs + Component Collections
// ========================================

type EntityId = string; // UUID or incremental number

interface Entity {
  id: EntityId;
  components: Set<ComponentType>;
}

// ========================================
// COMPONENTS: Pure Data Containers
// ========================================

enum ComponentType {
  Transform = "Transform",
  Health = "Health",
  Combat = "Combat",
  Movement = "Movement",
  AI = "AI",
  Abilities = "Abilities",
  Status = "Status",
}

interface TransformComponent {
  type: ComponentType.Transform;
  x: number; // Grid column
  y: number; // Grid row
  facing: Direction;
}

interface HealthComponent {
  type: ComponentType.Health;
  current: number;
  max: number;
  armor: number;
  regen: number; // HP per second
}

interface CombatComponent {
  type: ComponentType.Combat;
  damage: number;
  attackSpeed: number; // Attacks per second
  attackRange: number; // Tiles
  lastAttackTime: number;
  target: EntityId | null;
}

interface MovementComponent {
  type: ComponentType.Movement;
  speed: number; // Tiles per second
  movementType: "walker" | "charger" | "stationary" | "kiter" | "teleporter";
  currentPath: GridPosition[] | null;
}

interface AIComponent {
  type: ComponentType.AI;
  behavior: AIBehavior;
  state: AIState;
  aggro: Map<EntityId, number>; // Threat table
}

enum AIBehavior {
  MeleeAggressive = "MeleeAggressive",
  RangedKiter = "RangedKiter",
  SupportHealer = "SupportHealer",
  BossMechanics = "BossMechanics",
}

enum AIState {
  Idle = "Idle",
  Moving = "Moving",
  Attacking = "Attacking",
  Casting = "Casting",
  Fleeing = "Fleeing",
}

interface AbilitiesComponent {
  type: ComponentType.Abilities;
  abilities: Ability[];
}

interface Ability {
  id: string;
  name: string;
  cooldown: number;
  lastUsedTime: number;
  execute: (caster: EntityId, world: World) => void;
}

interface StatusComponent {
  type: ComponentType.Status;
  effects: StatusEffect[];
}

interface StatusEffect {
  type: "stun" | "slow" | "poison" | "buff" | "debuff";
  duration: number;
  value: number;
  tickInterval?: number; // For DoTs
  lastTickTime?: number;
}

// ========================================
// WORLD: Central State Container
// ========================================

class World {
  private entities: Map<EntityId, Entity> = new Map();
  private components: Map<ComponentType, Map<EntityId, any>> = new Map();
  private gameTime: number = 0;
  
  constructor() {
    // Initialize component storage
    Object.values(ComponentType).forEach(type => {
      this.components.set(type, new Map());
    });
  }
  
  // Entity management
  createEntity(): EntityId {
    const id = crypto.randomUUID();
    this.entities.set(id, { id, components: new Set() });
    return id;
  }
  
  destroyEntity(id: EntityId): void {
    const entity = this.entities.get(id);
    if (!entity) return;
    
    // Remove all components
    entity.components.forEach(type => {
      this.components.get(type)?.delete(id);
    });
    this.entities.delete(id);
  }
  
  // Component management
  addComponent<T>(entityId: EntityId, component: T & { type: ComponentType }): void {
    const entity = this.entities.get(entityId);
    if (!entity) return;
    
    entity.components.add(component.type);
    this.components.get(component.type)?.set(entityId, component);
  }
  
  getComponent<T>(entityId: EntityId, type: ComponentType): T | undefined {
    return this.components.get(type)?.get(entityId);
  }
  
  hasComponent(entityId: EntityId, type: ComponentType): boolean {
    return this.entities.get(entityId)?.components.has(type) ?? false;
  }
  
  // Query entities with specific components
  query(...componentTypes: ComponentType[]): EntityId[] {
    const results: EntityId[] = [];
    
    this.entities.forEach((entity, id) => {
      if (componentTypes.every(type => entity.components.has(type))) {
        results.push(id);
      }
    });
    
    return results;
  }
  
  getGameTime(): number {
    return this.gameTime;
  }
  
  advanceTime(deltaTime: number): void {
    this.gameTime += deltaTime;
  }
}

// ========================================
// SYSTEMS: Behavior Logic
// ========================================

abstract class System {
  abstract update(world: World, deltaTime: number): void;
}

class MovementSystem extends System {
  update(world: World, deltaTime: number): void {
    // Query all entities with Transform + Movement components
    const movingEntities = world.query(ComponentType.Transform, ComponentType.Movement);
    
    movingEntities.forEach(entityId => {
      const transform = world.getComponent<TransformComponent>(entityId, ComponentType.Transform);
      const movement = world.getComponent<MovementComponent>(entityId, ComponentType.Movement);
      
      if (!transform || !movement) return;
      if (movement.movementType === "stationary") return;
      if (!movement.currentPath || movement.currentPath.length === 0) return;
      
      // Move toward next position in path
      const targetPos = movement.currentPath[0];
      const distance = movement.speed * deltaTime;
      
      const dx = targetPos.x - transform.x;
      const dy = targetPos.y - transform.y;
      const distToTarget = Math.sqrt(dx * dx + dy * dy);
      
      if (distToTarget <= distance) {
        // Reached waypoint
        transform.x = targetPos.x;
        transform.y = targetPos.y;
        movement.currentPath.shift(); // Remove reached waypoint
      } else {
        // Move toward waypoint
        const ratio = distance / distToTarget;
        transform.x += dx * ratio;
        transform.y += dy * ratio;
      }
    });
  }
}

class CombatSystem extends System {
  update(world: World, deltaTime: number): void {
    const combatEntities = world.query(ComponentType.Combat, ComponentType.Transform);
    
    combatEntities.forEach(attackerId => {
      const combat = world.getComponent<CombatComponent>(attackerId, ComponentType.Combat);
      const transform = world.getComponent<TransformComponent>(attackerId, ComponentType.Transform);
      
      if (!combat || !transform) return;
      
      // Check if ready to attack
      const timeSinceLastAttack = world.getGameTime() - combat.lastAttackTime;
      const attackCooldown = 1 / combat.attackSpeed;
      
      if (timeSinceLastAttack < attackCooldown) return;
      
      // Find target if none
      if (!combat.target || !world.hasComponent(combat.target, ComponentType.Health)) {
        combat.target = this.findNearestTarget(world, attackerId, transform, combat.attackRange);
      }
      
      if (!combat.target) return;
      
      // Check if target in range
      const targetTransform = world.getComponent<TransformComponent>(combat.target, ComponentType.Transform);
      if (!targetTransform) return;
      
      const distance = this.getDistance(transform, targetTransform);
      if (distance > combat.attackRange) {
        combat.target = null; // Out of range
        return;
      }
      
      // Execute attack
      this.dealDamage(world, combat.target, combat.damage);
      combat.lastAttackTime = world.getGameTime();
    });
  }
  
  private findNearestTarget(
    world: World, 
    attackerId: EntityId, 
    attackerTransform: TransformComponent,
    range: number
  ): EntityId | null {
    const potentialTargets = world.query(ComponentType.Health, ComponentType.Transform);
    
    // Don't target self
    const validTargets = potentialTargets.filter(id => id !== attackerId);
    
    let nearest: EntityId | null = null;
    let nearestDist = Infinity;
    
    validTargets.forEach(targetId => {
      const targetTransform = world.getComponent<TransformComponent>(targetId, ComponentType.Transform);
      if (!targetTransform) return;
      
      const dist = this.getDistance(attackerTransform, targetTransform);
      if (dist <= range && dist < nearestDist) {
        nearest = targetId;
        nearestDist = dist;
      }
    });
    
    return nearest;
  }
  
  private dealDamage(world: World, targetId: EntityId, damage: number): void {
    const health = world.getComponent<HealthComponent>(targetId, ComponentType.Health);
    if (!health) return;
    
    // Apply armor reduction
    const actualDamage = Math.max(1, damage - health.armor);
    health.current = Math.max(0, health.current - actualDamage);
    
    // Check for death
    if (health.current <= 0) {
      this.handleDeath(world, targetId);
    }
  }
  
  private handleDeath(world: World, entityId: EntityId): void {
    // TODO: Trigger death effects, drop loot, etc.
    world.destroyEntity(entityId);
  }
  
  private getDistance(a: TransformComponent, b: TransformComponent): number {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}

class AISystem extends System {
  update(world: World, deltaTime: number): void {
    const aiEntities = world.query(ComponentType.AI, ComponentType.Transform, ComponentType.Combat);
    
    aiEntities.forEach(entityId => {
      const ai = world.getComponent<AIComponent>(entityId, ComponentType.AI);
      const transform = world.getComponent<TransformComponent>(entityId, ComponentType.Transform);
      const combat = world.getComponent<CombatComponent>(entityId, ComponentType.Combat);
      
      if (!ai || !transform || !combat) return;
      
      // Execute AI behavior based on type
      switch (ai.behavior) {
        case AIBehavior.MeleeAggressive:
          this.meleeAggressiveBehavior(world, entityId, ai, transform, combat);
          break;
        case AIBehavior.RangedKiter:
          this.rangedKiterBehavior(world, entityId, ai, transform, combat);
          break;
        case AIBehavior.SupportHealer:
          this.supportHealerBehavior(world, entityId, ai, transform);
          break;
        case AIBehavior.BossMechanics:
          this.bossMechanicsBehavior(world, entityId, ai, transform, combat);
          break;
      }
    });
  }
  
  private meleeAggressiveBehavior(
    world: World,
    entityId: EntityId,
    ai: AIComponent,
    transform: TransformComponent,
    combat: CombatComponent
  ): void {
    // Simple AI: Move toward nearest enemy, attack when in range
    
    if (combat.target && world.hasComponent(combat.target, ComponentType.Health)) {
      const targetTransform = world.getComponent<TransformComponent>(combat.target, ComponentType.Transform);
      if (!targetTransform) return;
      
      const distance = this.getDistance(transform, targetTransform);
      
      if (distance > combat.attackRange) {
        // Move toward target
        ai.state = AIState.Moving;
        const movement = world.getComponent<MovementComponent>(entityId, ComponentType.Movement);
        if (movement) {
          movement.currentPath = this.findPath(transform, targetTransform);
        }
      } else {
        // In range, attack handled by CombatSystem
        ai.state = AIState.Attacking;
      }
    } else {
      // No target, find one
      ai.state = AIState.Idle;
      const nearestEnemy = this.findNearestEnemy(world, entityId, transform);
      if (nearestEnemy) {
        combat.target = nearestEnemy;
      }
    }
  }
  
  private rangedKiterBehavior(
    world: World,
    entityId: EntityId,
    ai: AIComponent,
    transform: TransformComponent,
    combat: CombatComponent
  ): void {
    // Ranged AI: Maintain distance, flee if enemy gets too close
    
    const MIN_DISTANCE = 3; // Tiles
    const MAX_DISTANCE = combat.attackRange;
    
    if (combat.target && world.hasComponent(combat.target, ComponentType.Health)) {
      const targetTransform = world.getComponent<TransformComponent>(combat.target, ComponentType.Transform);
      if (!targetTransform) return;
      
      const distance = this.getDistance(transform, targetTransform);
      
      if (distance < MIN_DISTANCE) {
        // Too close, flee
        ai.state = AIState.Fleeing;
        const movement = world.getComponent<MovementComponent>(entityId, ComponentType.Movement);
        if (movement) {
          // Calculate flee direction (away from target)
          const fleePos = this.calculateFleePosition(transform, targetTransform);
          movement.currentPath = [fleePos];
        }
      } else if (distance > MAX_DISTANCE) {
        // Too far, move closer
        ai.state = AIState.Moving;
        const movement = world.getComponent<MovementComponent>(entityId, ComponentType.Movement);
        if (movement) {
          movement.currentPath = this.findPath(transform, targetTransform);
        }
      } else {
        // In sweet spot, attack
        ai.state = AIState.Attacking;
      }
    } else {
      // Find target
      combat.target = this.findNearestEnemy(world, entityId, transform);
    }
  }
  
  private supportHealerBehavior(
    world: World,
    entityId: EntityId,
    ai: AIComponent,
    transform: TransformComponent
  ): void {
    // Support AI: Heal lowest HP ally
    
    const allies = this.findAllies(world, entityId);
    let lowestHPAlly: EntityId | null = null;
    let lowestHPPercent = 1.0;
    
    allies.forEach(allyId => {
      const health = world.getComponent<HealthComponent>(allyId, ComponentType.Health);
      if (!health) return;
      
      const hpPercent = health.current / health.max;
      if (hpPercent < lowestHPPercent && hpPercent < 0.8) {
        lowestHPPercent = hpPercent;
        lowestHPAlly = allyId;
      }
    });
    
    if (lowestHPAlly) {
      // TODO: Cast heal ability
      ai.state = AIState.Casting;
    } else {
      ai.state = AIState.Idle;
    }
  }
  
  private bossMechanicsBehavior(
    world: World,
    entityId: EntityId,
    ai: AIComponent,
    transform: TransformComponent,
    combat: CombatComponent
  ): void {
    // Boss AI: Phase-based behavior
    // This would be customized per boss
    
    const health = world.getComponent<HealthComponent>(entityId, ComponentType.Health);
    if (!health) return;
    
    const hpPercent = health.current / health.max;
    
    if (hpPercent > 0.66) {
      // Phase 1: Aggressive melee
      this.meleeAggressiveBehavior(world, entityId, ai, transform, combat);
    } else if (hpPercent > 0.33) {
      // Phase 2: Summon adds (would trigger ability)
      ai.state = AIState.Casting;
      // TODO: Trigger summon ability
    } else {
      // Phase 3: Enraged, faster attacks
      combat.attackSpeed *= 1.5;
      this.meleeAggressiveBehavior(world, entityId, ai, transform, combat);
    }
  }
  
  // Helper methods
  private findNearestEnemy(world: World, entityId: EntityId, transform: TransformComponent): EntityId | null {
    // Simplified: Return first enemy found
    // TODO: Implement proper team/faction system
    const allEntities = world.query(ComponentType.Transform, ComponentType.Health);
    const enemies = allEntities.filter(id => id !== entityId);
    
    if (enemies.length === 0) return null;
    
    let nearest = enemies[0];
    let nearestDist = Infinity;
    
    enemies.forEach(enemyId => {
      const enemyTransform = world.getComponent<TransformComponent>(enemyId, ComponentType.Transform);
      if (!enemyTransform) return;
      
      const dist = this.getDistance(transform, enemyTransform);
      if (dist < nearestDist) {
        nearest = enemyId;
        nearestDist = dist;
      }
    });
    
    return nearest;
  }
  
  private findAllies(world: World, entityId: EntityId): EntityId[] {
    // TODO: Implement faction system
    return [];
  }
  
  private findPath(from: TransformComponent, to: TransformComponent): GridPosition[] {
    // Simplified pathfinding: Direct line
    // TODO: Implement A* pathfinding
    return [{ x: to.x, y: to.y }];
  }
  
  private calculateFleePosition(from: TransformComponent, threat: TransformComponent): GridPosition {
    // Calculate position away from threat
    const dx = from.x - threat.x;
    const dy = from.y - threat.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) return { x: from.x + 1, y: from.y };
    
    // Move 3 tiles away from threat
    const fleeDistance = 3;
    return {
      x: from.x + (dx / distance) * fleeDistance,
      y: from.y + (dy / distance) * fleeDistance,
    };
  }
  
  private getDistance(a: TransformComponent, b: TransformComponent): number {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}

class AbilitySystem extends System {
  update(world: World, deltaTime: number): void {
    const abilityEntities = world.query(ComponentType.Abilities, ComponentType.AI);
    
    abilityEntities.forEach(entityId => {
      const abilities = world.getComponent<AbilitiesComponent>(entityId, ComponentType.Abilities);
      const ai = world.getComponent<AIComponent>(entityId, ComponentType.AI);
      
      if (!abilities || !ai) return;
      
      abilities.abilities.forEach(ability => {
        const timeSinceLastUse = world.getGameTime() - ability.lastUsedTime;
        
        if (timeSinceLastUse >= ability.cooldown) {
          // Check if ability should be used (AI decision)
          if (this.shouldUseAbility(world, entityId, ability, ai)) {
            ability.execute(entityId, world);
            ability.lastUsedTime = world.getGameTime();
          }
        }
      });
    });
  }
  
  private shouldUseAbility(
    world: World,
    entityId: EntityId,
    ability: Ability,
    ai: AIComponent
  ): boolean {
    // Simple heuristic: Use ability when off cooldown and in combat
    return ai.state === AIState.Attacking || ai.state === AIState.Casting;
  }
}

class StatusEffectSystem extends System {
  update(world: World, deltaTime: number): void {
    const statusEntities = world.query(ComponentType.Status);
    
    statusEntities.forEach(entityId => {
      const status = world.getComponent<StatusComponent>(entityId, ComponentType.Status);
      if (!status) return;
      
      // Update all status effects
      status.effects = status.effects.filter(effect => {
        effect.duration -= deltaTime;
        
        // Tick DoT effects
        if (effect.tickInterval) {
          effect.lastTickTime = effect.lastTickTime ?? world.getGameTime();
          const timeSinceLastTick = world.getGameTime() - effect.lastTickTime;
          
          if (timeSinceLastTick >= effect.tickInterval) {
            this.applyEffectTick(world, entityId, effect);
            effect.lastTickTime = world.getGameTime();
          }
        }
        
        // Remove expired effects
        return effect.duration > 0;
      });
    });
  }
  
  private applyEffectTick(world: World, entityId: EntityId, effect: StatusEffect): void {
    if (effect.type === "poison") {
      const health = world.getComponent<HealthComponent>(entityId, ComponentType.Health);
      if (health) {
        health.current = Math.max(0, health.current - effect.value);
      }
    }
    // Add other effect types as needed
  }
}

// ========================================
// GAME SIMULATION: Orchestrates Systems
// ========================================

class CombatSimulation {
  private world: World;
  private systems: System[];
  private isRunning: boolean = false;
  
  constructor() {
    this.world = new World();
    this.systems = [
      new AISystem(),
      new MovementSystem(),
      new CombatSystem(),
      new AbilitySystem(),
      new StatusEffectSystem(),
    ];
  }
  
  public start(): void {
    this.isRunning = true;
  }
  
  public stop(): void {
    this.isRunning = false;
  }
  
  public tick(deltaTime: number): void {
    if (!this.isRunning) return;
    
    // Update game time
    this.world.advanceTime(deltaTime);
    
    // Run all systems
    this.systems.forEach(system => {
      system.update(this.world, deltaTime);
    });
  }
  
  public getState(): GameState {
    // Extract state for React rendering
    return {
      entities: this.serializeEntities(),
      gameTime: this.world.getGameTime(),
    };
  }
  
  private serializeEntities(): SerializedEntity[] {
    // Convert world state to React-friendly format
    const entities: SerializedEntity[] = [];
    
    const allEntities = this.world.query(ComponentType.Transform);
    allEntities.forEach(id => {
      const transform = this.world.getComponent<TransformComponent>(id, ComponentType.Transform);
      const health = this.world.getComponent<HealthComponent>(id, ComponentType.Health);
      const combat = this.world.getComponent<CombatComponent>(id, ComponentType.Combat);
      
      entities.push({
        id,
        x: transform!.x,
        y: transform!.y,
        hp: health?.current,
        maxHp: health?.max,
        isAttacking: combat?.lastAttackTime === this.world.getGameTime(),
      });
    });
    
    return entities;
  }
  
  // Factory methods for creating entities
  public spawnHero(heroType: string, x: number, y: number): EntityId {
    const id = this.world.createEntity();
    
    // Add components based on hero type
    this.world.addComponent(id, {
      type: ComponentType.Transform,
      x, y,
      facing: Direction.Right,
    });
    
    this.world.addComponent(id, {
      type: ComponentType.Health,
      current: 200,
      max: 200,
      armor: 10,
      regen: 0,
    });
    
    this.world.addComponent(id, {
      type: ComponentType.Combat,
      damage: 25,
      attackSpeed: 1,
      attackRange: 1,
      lastAttackTime: 0,
      target: null,
    });
    
    this.world.addComponent(id, {
      type: ComponentType.Movement,
      speed: 2,
      movementType: "walker",
      currentPath: null,
    });
    
    this.world.addComponent(id, {
      type: ComponentType.AI,
      behavior: AIBehavior.MeleeAggressive,
      state: AIState.Idle,
      aggro: new Map(),
    });
    
    return id;
  }
  
  public spawnEnemy(enemyType: string, x: number, y: number): EntityId {
    // Similar to spawnHero, but with enemy stats
    const id = this.world.createEntity();
    
    // Add components...
    
    return id;
  }
}

// ========================================
// REACT INTEGRATION
// ========================================

interface GameState {
  entities: SerializedEntity[];
  gameTime: number;
}

interface SerializedEntity {
  id: string;
  x: number;
  y: number;
  hp?: number;
  maxHp?: number;
  isAttacking: boolean;
}

enum Direction {
  Up = "Up",
  Down = "Down",
  Left = "Left",
  Right = "Right",
}

interface GridPosition {
  x: number;
  y: number;
}

function CombatArena() {
  const simulationRef = useRef<CombatSimulation>(new CombatSimulation());
  const [gameState, setGameState] = useState<GameState>({
    entities: [],
    gameTime: 0,
  });
  const [isPlaying, setIsPlaying] = useState(false);
  const [speed, setSpeed] = useState(1); // 1x, 2x, 4x, 8x
  
  useEffect(() => {
    if (!isPlaying) return;
    
    const TICK_RATE = 100; // ms (10 FPS for logic)
    const actualTickRate = TICK_RATE / speed;
    
    const interval = setInterval(() => {
      simulationRef.current.tick(TICK_RATE / 1000); // Convert to seconds
      setGameState(simulationRef.current.getState());
    }, actualTickRate);
    
    return () => clearInterval(interval);
  }, [isPlaying, speed]);
  
  const handleStart = () => {
    // Spawn heroes and enemies
    simulationRef.current.spawnHero("Knight", 2, 5);
    simulationRef.current.spawnHero("Ranger", 1, 5);
    simulationRef.current.spawnEnemy("Wolf", 10, 5);
    
    simulationRef.current.start();
    setIsPlaying(true);
  };
  
  return (
    <div className="combat-arena">
      <GridRenderer entities={gameState.entities} />
      
      <div className="controls">
        <button onClick={handleStart}>Start Combat</button>
        <button onClick={() => setSpeed(speed === 8 ? 1 : speed * 2)}>
          Speed: {speed}x
        </button>
      </div>
    </div>
  );
}

function GridRenderer({ entities }: { entities: SerializedEntity[] }) {
  return (
    <div className="grid">
      {entities.map(entity => (
        <div
          key={entity.id}
          className="entity"
          style={{
            gridColumn: entity.x + 1,
            gridRow: entity.y + 1,
          }}
        >
          {entity.hp && (
            <div className="health-bar">
              <div 
                className="health-fill"
                style={{ width: `${(entity.hp / entity.maxHp!) * 100}%` }}
              />
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

---

## Performance Optimization Strategies

### 1. Object Pooling

```typescript
class EntityPool {
  private pool: Entity[] = [];
  
  public acquire(): Entity {
    return this.pool.pop() || this.createNew();
  }
  
  public release(entity: Entity): void {
    this.reset(entity);
    this.pool.push(entity);
  }
  
  private createNew(): Entity {
    return { id: "", components: new Set() };
  }
  
  private reset(entity: Entity): void {
    entity.components.clear();
  }
}
```

### 2. Spatial Partitioning (for large battlefields)

```typescript
class SpatialGrid {
  private cells: Map<string, EntityId[]> = new Map();
  private cellSize: number = 3; // Grid cells are 3×3 tiles
  
  public insert(entityId: EntityId, x: number, y: number): void {
    const cellKey = this.getCellKey(x, y);
    if (!this.cells.has(cellKey)) {
      this.cells.set(cellKey, []);
    }
    this.cells.get(cellKey)!.push(entityId);
  }
  
  public queryNearby(x: number, y: number, radius: number): EntityId[] {
    const results: EntityId[] = [];
    
    // Check only nearby cells
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const cellKey = this.getCellKey(x + dx * this.cellSize, y + dy * this.cellSize);
        const cellEntities = this.cells.get(cellKey) || [];
        results.push(...cellEntities);
      }
    }
    
    return results;
  }
  
  private getCellKey(x: number, y: number): string {
    const cellX = Math.floor(x / this.cellSize);
    const cellY = Math.floor(y / this.cellSize);
    return `${cellX},${cellY}`;
  }
}
```

### 3. Dirty Flag Pattern (Minimize React Re-renders)

```typescript
class CombatSimulation {
  private dirtyEntities: Set<EntityId> = new Set();
  
  public getState(): GameState {
    // Only serialize entities that changed
    const entities = Array.from(this.dirtyEntities).map(id => {
      return this.serializeEntity(id);
    });
    
    this.dirtyEntities.clear();
    
    return { entities, gameTime: this.world.getGameTime() };
  }
  
  private markDirty(entityId: EntityId): void {
    this.dirtyEntities.add(entityId);
  }
}

// In React:
function GridRenderer({ entities }: { entities: SerializedEntity[] }) {
  const entityMapRef = useRef(new Map<string, SerializedEntity>());
  
  // Update only changed entities
  entities.forEach(entity => {
    entityMapRef.current.set(entity.id, entity);
  });
  
  return (
    <div className="grid">
      {Array.from(entityMapRef.current.values()).map(entity => (
        <Entity key={entity.id} data={entity} />
      ))}
    </div>
  );
}

const Entity = React.memo(({ data }: { data: SerializedEntity }) => {
  // Only re-renders when data actually changes
  return <div className="entity" style={{ /* ... */ }} />;
});
```

### 4. Web Workers (For Heavy Computation)

```typescript
// combat-worker.ts
const simulation = new CombatSimulation();

self.onmessage = (e) => {
  switch (e.data.type) {
    case "TICK":
      simulation.tick(e.data.deltaTime);
      const state = simulation.getState();
      self.postMessage({ type: "STATE_UPDATE", state });
      break;
      
    case "SPAWN_HERO":
      simulation.spawnHero(e.data.heroType, e.data.x, e.data.y);
      break;
  }
};

// In React:
function CombatArena() {
  const workerRef = useRef<Worker>();
  const [gameState, setGameState] = useState<GameState>();
  
  useEffect(() => {
    workerRef.current = new Worker(new URL("./combat-worker.ts", import.meta.url));
    
    workerRef.current.onmessage = (e) => {
      if (e.data.type === "STATE_UPDATE") {
        setGameState(e.data.state);
      }
    };
    
    return () => workerRef.current?.terminate();
  }, []);
  
  useEffect(() => {
    const interval = setInterval(() => {
      workerRef.current?.postMessage({ type: "TICK", deltaTime: 0.1 });
    }, 100);
    
    return () => clearInterval(interval);
  }, []);
  
  // ...
}
```

---

## Advanced AI: Behavior Trees

For more complex AI (bosses, tactical enemies):

```typescript
abstract class BehaviorNode {
  abstract execute(entityId: EntityId, world: World): NodeResult;
}

enum NodeResult {
  Success = "Success",
  Failure = "Failure",
  Running = "Running",
}

class SequenceNode extends BehaviorNode {
  constructor(private children: BehaviorNode[]) {
    super();
  }
  
  execute(entityId: EntityId, world: World): NodeResult {
    for (const child of this.children) {
      const result = child.execute(entityId, world);
      
      if (result !== NodeResult.Success) {
        return result; // Return failure or running
      }
    }
    
    return NodeResult.Success;
  }
}

class SelectorNode extends BehaviorNode {
  constructor(private children: BehaviorNode[]) {
    super();
  }
  
  execute(entityId: EntityId, world: World): NodeResult {
    for (const child of this.children) {
      const result = child.execute(entityId, world);
      
      if (result !== NodeResult.Failure) {
        return result; // Return success or running
      }
    }
    
    return NodeResult.Failure;
  }
}

class ConditionNode extends BehaviorNode {
  constructor(private condition: (entityId: EntityId, world: World) => boolean) {
    super();
  }
  
  execute(entityId: EntityId, world: World): NodeResult {
    return this.condition(entityId, world) ? NodeResult.Success : NodeResult.Failure;
  }
}

class ActionNode extends BehaviorNode {
  constructor(private action: (entityId: EntityId, world: World) => NodeResult) {
    super();
  }
  
  execute(entityId: EntityId, world: World): NodeResult {
    return this.action(entityId, world);
  }
}

// Example: Boss AI Behavior Tree
class BossAI {
  private behaviorTree: BehaviorNode;
  
  constructor() {
    this.behaviorTree = new SelectorNode([
      // Phase 3: Enraged (HP < 33%)
      new SequenceNode([
        new ConditionNode((id, world) => {
          const health = world.getComponent<HealthComponent>(id, ComponentType.Health);
          return (health!.current / health!.max) < 0.33;
        }),
        new ActionNode((id, world) => {
          // Execute enraged behavior
          return NodeResult.Success;
        }),
      ]),
      
      // Phase 2: Summons (HP < 66%)
      new SequenceNode([
        new ConditionNode((id, world) => {
          const health = world.getComponent<HealthComponent>(id, ComponentType.Health);
          return (health!.current / health!.max) < 0.66;
        }),
        new ActionNode((id, world) => {
          // Summon minions
          return NodeResult.Success;
        }),
      ]),
      
      // Phase 1: Default aggressive
      new ActionNode((id, world) => {
        // Melee attacks
        return NodeResult.Success;
      }),
    ]);
  }
  
  public update(entityId: EntityId, world: World): void {
    this.behaviorTree.execute(entityId, world);
  }
}
```

---

## Pathfinding: A* Algorithm

```typescript
class Pathfinder {
  private grid: boolean[][]; // true = walkable, false = blocked
  
  constructor(width: number, height: number) {
    this.grid = Array(height).fill(null).map(() => Array(width).fill(true));
  }
  
  public findPath(start: GridPosition, goal: GridPosition): GridPosition[] {
    const openSet: PathNode[] = [];
    const closedSet = new Set<string>();
    
    const startNode: PathNode = {
      pos: start,
      g: 0,
      h: this.heuristic(start, goal),
      f: 0,
      parent: null,
    };
    startNode.f = startNode.g + startNode.h;
    
    openSet.push(startNode);
    
    while (openSet.length > 0) {
      // Get node with lowest f score
      openSet.sort((a, b) => a.f - b.f);
      const current = openSet.shift()!;
      
      // Goal reached
      if (current.pos.x === goal.x && current.pos.y === goal.y) {
        return this.reconstructPath(current);
      }
      
      closedSet.add(this.posKey(current.pos));
      
      // Check neighbors
      const neighbors = this.getNeighbors(current.pos);
      
      for (const neighborPos of neighbors) {
        if (closedSet.has(this.posKey(neighborPos))) continue;
        if (!this.isWalkable(neighborPos)) continue;
        
        const g = current.g + 1;
        const h = this.heuristic(neighborPos, goal);
        const f = g + h;
        
        // Check if neighbor already in open set with better score
        const existing = openSet.find(n => 
          n.pos.x === neighborPos.x && n.pos.y === neighborPos.y
        );
        
        if (existing && g >= existing.g) continue;
        
        const neighborNode: PathNode = {
          pos: neighborPos,
          g, h, f,
          parent: current,
        };
        
        if (existing) {
          // Update existing node
          Object.assign(existing, neighborNode);
        } else {
          openSet.push(neighborNode);
        }
      }
    }
    
    return []; // No path found
  }
  
  private heuristic(a: GridPosition, b: GridPosition): number {
    // Manhattan distance
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  }
  
  private getNeighbors(pos: GridPosition): GridPosition[] {
    return [
      { x: pos.x + 1, y: pos.y },
      { x: pos.x - 1, y: pos.y },
      { x: pos.x, y: pos.y + 1 },
      { x: pos.x, y: pos.y - 1 },
    ].filter(p => 
      p.x >= 0 && p.x < this.grid[0].length &&
      p.y >= 0 && p.y < this.grid.length
    );
  }
  
  private isWalkable(pos: GridPosition): boolean {
    return this.grid[pos.y][pos.x];
  }
  
  private posKey(pos: GridPosition): string {
    return `${pos.x},${pos.y}`;
  }
  
  private reconstructPath(node: PathNode): GridPosition[] {
    const path: GridPosition[] = [];
    let current: PathNode | null = node;
    
    while (current) {
      path.unshift(current.pos);
      current = current.parent;
    }
    
    return path;
  }
}

interface PathNode {
  pos: GridPosition;
  g: number; // Cost from start
  h: number; // Heuristic to goal
  f: number; // Total cost
  parent: PathNode | null;
}
```

---

## Performance Benchmarks & Limits

### Expected Performance (TypeScript/React)

**With ECS Architecture:**
- 50-100 entities: 60 FPS easily
- 100-200 entities: 30-60 FPS
- 200+ entities: Consider Web Workers

**System Update Times (target <16ms per frame):**
- AI System: ~2-5ms for 50 entities
- Movement System: ~1-2ms
- Combat System: ~2-4ms
- Pathfinding (A*): ~1-10ms depending on grid size

### Optimization Thresholds

**When to optimize:**
- Frame time exceeds 16ms (60 FPS) or 33ms (30 FPS)
- State updates cause visible React lag
- Memory usage grows unbounded

**Quick fixes:**
1. Reduce tick rate (10 FPS logic is fine for autobattlers)
2. Use React.memo() on entity components
3. Batch state updates (don't call setState per entity)
4. Profile with Chrome DevTools to find bottlenecks

---

## Testing Strategy

```typescript
describe("CombatSimulation", () => {
  it("should damage enemies when hero attacks", () => {
    const sim = new CombatSimulation();
    const heroId = sim.spawnHero("Knight", 5, 5);
    const enemyId = sim.spawnEnemy("Wolf", 6, 5);
    
    // Simulate until hero attacks
    for (let i = 0; i < 20; i++) {
      sim.tick(0.1);
    }
    
    const world = sim.getWorld();
    const enemyHealth = world.getComponent<HealthComponent>(
      enemyId, 
      ComponentType.Health
    );
    
    expect(enemyHealth!.current).toBeLessThan(enemyHealth!.max);
  });
  
  it("should destroy entity when HP reaches 0", () => {
    const sim = new CombatSimulation();
    const enemyId = sim.spawnEnemy("Wolf", 5, 5);
    
    const world = sim.getWorld();
    const health = world.getComponent<HealthComponent>(
      enemyId,
      ComponentType.Health
    );
    
    health!.current = 1;
    
    // Deal damage
    sim.tick(0.1);
    
    const stillExists = world.hasComponent(enemyId, ComponentType.Health);
    expect(stillExists).toBe(false);
  });
});
```

---

## Summary: Can React/TypeScript Handle This?

**YES, absolutely.**

**Pros:**
- ✅ ECS architecture scales to 100+ entities
- ✅ Separation of logic/rendering keeps React fast
- ✅ TypeScript provides type safety for complex state
- ✅ Can run simulation in Web Worker if needed
- ✅ Easy to serialize/save game state

**Cons:**
- ⚠️ Need disciplined architecture (don't mix logic in React)
- ⚠️ Pathfinding can be expensive (cache paths, use simple heuristics)
- ⚠️ Avoid object creation in hot loops (use pooling)

**Recommended Approach:**
1. Start with ECS-lite pattern (components + systems)
2. Keep tick rate at 10-20 FPS for logic (separate from 60 FPS rendering)
3. Profile early, optimize when needed
4. Use Web Workers for 200+ entities or complex bosses

**You're in good shape!** This architecture will handle everything in your design docs.

---

**Document Version:** 1.0  
**Last Updated:** December 2025  
**Contributors:** Alex (Design Lead), Claude (AI Architecture Advisor)

**Status:** Architecture validated, ready for implementation